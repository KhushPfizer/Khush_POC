import { Subject } from 'rxjs';
import { UneeqMessage } from '..';
import { MessagingService } from './messaging';
/**
 * Uneeq WebRTC implementation which hides the complexity of making a WebRTC call.
 */
export declare class UneeqWebRTC {
    private client;
    private readonly uniqueId;
    private readonly options;
    private readonly fakeDataChannel;
    private statTimer?;
    private readonly MESSAGING_ENDPOINT;
    constructor(options: UneeqWebRTCOptions);
    /**
     * Start a connection with the given streams.
     */
    connect(stream: MediaStream): void;
    /**
     * Close the connection.
     */
    close(): void;
    /**
     * Handle the WebRTC answer message
     * @return boolean true if we handled this
     */
    handleAnswerMessage(msg: any): boolean;
    /**
     * Handle the ice candidate message.
     * @return boolean true if we handled this
     */
    handleIceCandidate(msg: any): boolean;
    sendDataMessage(message: string): void;
    getStats(callback: any): any;
    updateStreamTracks(stream: MediaStream): void;
    private onStats;
    private enableDiagnostics;
    private isMessageForUs;
    /**
     * Log a message to the console. This will prepend our UneeqWebRTC prefix.
     */
    private log;
    /**
     * Log a message to the console as a warning. This will prepend our UneeqWebRTC prefix.
     */
    private warn;
}
/**
 * The options for the WebRTC class.
 * Note: this isn't an interface so that we can have default values.
 */
export interface UneeqWebRTCOptions {
    messaging: MessagingService;
    userMessages: Subject<UneeqMessage>;
    edgeNodeId: string;
    publishStreamName: string;
    subscribeStreamName: string;
    iceServers?: RTCIceServer[];
    forceTurnServerUse?: boolean;
    diagnostics?: boolean;
    onAddStream?: (stream: any) => void;
    onConnect?: () => void;
    onData?: (data: any) => void;
    onClose?: () => void;
    onError?: (error: any) => void;
}
