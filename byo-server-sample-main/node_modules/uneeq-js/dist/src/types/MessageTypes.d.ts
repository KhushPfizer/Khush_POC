import { ChatMetadata } from './ChatMetadata';
import { ClientPerformanceStats } from './ClientPerformanceStats';
import { PublishSubscribeState } from './PublishSubscribeState';
import { SpeechTranscriptionResult } from './SpeechTranscriptionResult';
import { Devices } from './types';
export interface UneeqMessage {
    uneeqMessageType: UneeqMessageType;
}
export declare enum UneeqMessageType {
    Ready = "Ready",
    DeviceNotFoundError = "DeviceNotFoundError",
    SetCameraSuccess = "SetCameraSuccess",
    SetMicSuccess = "SetMicSuccess",
    SetSpeakerSuccess = "SetSpeakerSuccess",
    SessionPaused = "SessionPaused",
    SessionResumed = "SessionResumed",
    SessionEnded = "SessionEnded",
    AvatarAvailable = "AvatarAvailable",
    AvatarUnavailable = "AvatarUnavailable",
    ConnectionLost = "ConnectionLost",
    ResumeSessionUnavailable = "ResumeSessionUnavailable",
    ServiceUnavailable = "ServiceUnavailable",
    OnlineStatusUpdate = "OnlineStatusUpdate",
    MicActivityNotSupported = "MicActivityNotSupported",
    VoiceActivityInputModeNotSupported = "VoiceActivityInputModeNotSupported",
    MicActivityError = "MicActivityError",
    MicActivity = "MicActivity",
    DeviceError = "DeviceError",
    DeviceListUpdated = "DeviceListUpdated",
    AvatarAnswer = "AvatarAnswer",
    AvatarAnswerContent = "AvatarAnswerContent",
    Instructions = "Instructions",
    StartedSpeaking = "StartedSpeaking",
    FinishedSpeaking = "FinishedSpeaking",
    AvatarTextInputFinished = "AvatarTextInputFinished",
    AvatarQuestionText = "AvatarQuestionText",
    SpeechTranscription = "SpeechTranscription",
    UserStartedSpeaking = "UserStartedSpeaking",
    UserStoppedSpeaking = "UserStoppedSpeaking",
    DevicePermissionAllowed = "DevicePermissionAllowed",
    RecordingStarted = "RecordingStarted",
    RecordingStopped = "RecordingStopped",
    Warning = "Warning",
    SessionLive = "SessionLive",
    WebRtcData = "WebRtcData",
    WebRtcStats = "WebRtcStats",
    SessionError = "SessionError",
    SessionInfo = "SessionInfo",
    AvatarRequestCompleted = "AvatarRequestCompleted",
    AvatarRequestIgnored = "AvatarRequestIgnored",
    ClientMediaStreamUpdate = "ClientMediaStreamUpdate",
    ClientPerformanceMessage = "ClientPerformanceMessage",
    DigitalHumanVideoError = "DigitalHumanVideoError",
    DigitalHumanFailedToPlay = "DigitalHumanFailedToPlay",
    DigitalHumanPlayedInMutedModeSuccess = "DigitalHumanPlayedInMutedModeSuccess",
    DigitalHumanUnmuted = "DigitalHumanUnmuted",
    CustomMetadataUpdated = "CustomMetadataUpdated",
    VadInterruptionAllowed = "VadInterruptionAllowed",
    EnableMicrophoneUpdated = "EnableMicrophoneUpdated"
}
/**
 * Service is ready to be used
 */
export declare class ReadyMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Selected device is not found
 */
export declare class DeviceNotFoundErrorMessage implements UneeqMessage {
    readonly msg: string;
    readonly deviceId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(msg: string, deviceId: string);
}
/**
 * Users camera has been set successfully
 */
export declare class SetCameraSuccessMessage implements UneeqMessage {
    readonly deviceId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(deviceId: string);
}
/**
 * Users microphone has been set successfully
 */
export declare class SetMicSuccessMessage implements UneeqMessage {
    readonly deviceId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(deviceId: string);
}
/**
 * Users microphone has been enabled/disabled
 */
export declare class EnableMicrophoneUpdatedMessage implements UneeqMessage {
    readonly enabled: boolean;
    uneeqMessageType: UneeqMessageType;
    constructor(enabled: boolean);
}
/**
 * Users speaker has been set successfully
 */
export declare class SetSpeakerSuccessMessage implements UneeqMessage {
    readonly deviceId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(deviceId: string);
}
/**
 * An error has occured with the users device
 */
export declare class DeviceErrorMessage implements UneeqMessage {
    readonly error: Error;
    uneeqMessageType: UneeqMessageType;
    constructor(error: Error);
}
/**
 * The device list has been changed or retrieved for the first time
 */
export declare class DeviceListUpdatedMessage implements UneeqMessage {
    readonly devices: Devices;
    uneeqMessageType: UneeqMessageType;
    constructor(devices: Devices);
}
/**
 * Session has been paused successfully
 */
export declare class SessionPausedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Session has been resumed successfully
 */
export declare class SessionResumedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Session has been ended successfully
 */
export declare class SessionEndedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * An avatar is available
 */
export declare class AvatarAvailableMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * There are no avatars currently available
 */
export declare class AvatarUnavailableMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Service is unavailable
 */
export declare class ServiceUnavailableMessage implements UneeqMessage {
    readonly error: any;
    uneeqMessageType: UneeqMessageType;
    constructor(error: any);
}
/**
 * An error occured with mic activity messages
 */
export declare class MicActivityErrorMessage implements UneeqMessage {
    readonly error: Error;
    uneeqMessageType: UneeqMessageType;
    constructor(error: Error);
}
/**
 * Message is sent upon activity of the user microphone
 *
 * Visibility is controlled by UneeqOptions param micActivityMessages
 */
export declare class MicActivityMessage implements UneeqMessage {
    readonly level: number;
    uneeqMessageType: UneeqMessageType;
    constructor(level: number);
}
/**
 * Mic activity messages are not supported by the users browser
 *
 * Visibility is controlled by UneeqOptions param micActivityMessages
 */
export declare class MicActivityNotSupportedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Mic activity input mode is not supported by the users browser
 */
export declare class VoiceActivityInputModeNotSupportedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Connection Lost
 */
export declare class ConnectionLostMessage implements UneeqMessage {
    readonly connectionState: PublishSubscribeState;
    uneeqMessageType: UneeqMessageType;
    constructor(connectionState: PublishSubscribeState);
}
/**
 * Resume Session Unavailable
 */
export declare class ResumeSessionUnavailable implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * The avatar's answer to a question
 */
export declare class AvatarAnswerMessage implements UneeqMessage {
    readonly answer: string;
    readonly answerAvatar: string;
    readonly answerSpeech: string;
    readonly transcriptId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(answer: string, answerAvatar: string, answerSpeech: string, transcriptId: string);
}
/**
 * The avatar's answer to a question (HTML Content)
 */
export declare class AvatarAnswerContentMessage implements UneeqMessage {
    readonly content: string;
    readonly transcriptId: string;
    readonly hasDisplayHtml: boolean;
    uneeqMessageType: UneeqMessageType;
    /**
     * @param content Note: If `hasDisplayHtml` = true, this content will contain the HTML provided by the displayHTML instruction.
     * If `hasDisplayHtml` = false, this content will contain the `answer` value
     * @param transcriptId
     * @param hasDisplayHtml
     */
    constructor(content: string, transcriptId: string, hasDisplayHtml?: boolean);
}
export declare class InstructionsMessage implements UneeqMessage {
    readonly instructions: object;
    uneeqMessageType: UneeqMessageType;
    /**
     *
     * @param instructions is an object defined on the NLP which is passed to the client in response to certain questions
     */
    constructor(instructions: object);
}
/**
 * The question the user asked
 */
export declare class AvatarQuestionMessage implements UneeqMessage {
    readonly question: any;
    readonly transcriptId: string;
    uneeqMessageType: UneeqMessageType;
    constructor(question: any, transcriptId: string);
}
/**
 * The question the user asked
 */
export declare class SpeechTranscriptionMessage implements UneeqMessage {
    readonly speechTranscription: SpeechTranscriptionResult;
    uneeqMessageType: UneeqMessageType;
    constructor(speechTranscription: SpeechTranscriptionResult);
}
/**
 * VAD interruption status update
 */
export declare class VadInterruptionAllowedMessage implements UneeqMessage {
    readonly interruptionAllowed: boolean;
    uneeqMessageType: UneeqMessageType;
    constructor(interruptionAllowed: boolean);
}
/**
 * Digital human has started speaking the message
 */
export declare class UserStartedSpeakingMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Digital human has started speaking the message
 */
export declare class UserStoppedSpeakingMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Digital human has started speaking the message
 */
export declare class StartedSpeakingMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * Digital human has finished speaking the message
 */
export declare class FinishedSpeakingMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * [Deprecated] Avatar has finished speaking the message. Deprecated, use FinishedSpeakingMessage
 */
export declare class AvatarTextInputFinishedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * User has given permission to use devices
 */
export declare class DevicePermissionAllowedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * User has started a recording successfully
 */
export declare class RecordingStartedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * User has stopped recording successfully
 */
export declare class RecordingStoppedMessage implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
/**
 * General Warning Message - refer to msg
 */
export declare class WarningMessage implements UneeqMessage {
    readonly msg: string;
    uneeqMessageType: UneeqMessageType;
    constructor(msg: string);
}
/**
 * Session is Live, avatar video is active
 */
export declare class SessionLiveMessage implements UneeqMessage {
    readonly showLogo: boolean;
    readonly sessionResumed: boolean;
    uneeqMessageType: UneeqMessageType;
    constructor(showLogo: boolean, sessionResumed: boolean);
}
/**
 * WebRTC data channel message
 */
export declare class WebRtcDataMessage implements UneeqMessage {
    readonly data: any;
    uneeqMessageType: UneeqMessageType;
    constructor(data: any);
}
/**
 * WebRTC stats message (diagnostics)
 */
export declare class WebRtcStatsMessage implements UneeqMessage {
    readonly stats: any;
    uneeqMessageType: UneeqMessageType;
    constructor(stats: any);
}
/**
 * Session Error has occurred
 */
export declare class SessionErrorMessage implements UneeqMessage {
    readonly error: string;
    uneeqMessageType: UneeqMessageType;
    constructor(error: string);
}
/**
 * Avatar request completed: the Avatar has completed processing a text or instruction request
 */
export declare class AvatarRequestCompleted implements UneeqMessage {
    readonly reason: string;
    uneeqMessageType: UneeqMessageType;
    constructor(reason: string);
}
/**
 * Avatar request ignored: the Avatar has ignored a request to speak
 */
export declare class AvatarRequestIgnored implements UneeqMessage {
    readonly reason: string;
    uneeqMessageType: UneeqMessageType;
    constructor(reason: string);
}
/**
 * Session Info Messages: Primarily used for testing, e.g. the active behaviour tag
 */
export declare class SessionInfoMessage implements UneeqMessage {
    readonly info: string;
    uneeqMessageType: UneeqMessageType;
    constructor(info: string);
}
/**
 * Clients network status has changed. {online: true|false}
 */
export declare class OnlineStatusUpdateMessage implements UneeqMessage {
    readonly online: boolean;
    uneeqMessageType: UneeqMessageType;
    constructor(online: boolean);
}
export declare class ClientMediaStreamUpdateMessage implements UneeqMessage {
    readonly clientStreamingAudio: boolean;
    readonly clientStreamingVideo: boolean;
    readonly serverStreamingAudio: boolean;
    readonly serverStreamingVideo: boolean;
    uneeqMessageType: UneeqMessageType;
    constructor(clientStreamingAudio: boolean, clientStreamingVideo: boolean, serverStreamingAudio: boolean, serverStreamingVideo: boolean);
}
/**
 * These WebRTC statistics help identify if session quality is being impacted by client-side conditions.
 * Messages are sent every 5 seconds, and are visible in the console if enableClientPerformanceMessage = true.
 */
export declare class ClientPerformanceMessage implements UneeqMessage {
    readonly clientPerformance: ClientPerformanceStats;
    uneeqMessageType: UneeqMessageType;
    constructor(clientPerformance: ClientPerformanceStats);
}
/**
 * DigitalHuman Video Error has occurred
 */
export declare class DigitalHumanVideoError implements UneeqMessage {
    readonly error: any;
    uneeqMessageType: UneeqMessageType;
    constructor(error: any);
}
/**
 * DigitalHuman Failed to play
 */
export declare class DigitalHumanFailedToPlay implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    msg: string;
    constructor();
}
/**
 * DigitalHuman was successfully played in muted mode
 */
export declare class DigitalHumanPlayedInMutedModeSuccess implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    msg: string;
    constructor();
}
/**
 * DigitalHuman was unmuted
 */
export declare class DigitalHumanUnmuted implements UneeqMessage {
    uneeqMessageType: UneeqMessageType;
    constructor();
}
export declare class CustomMetadataUpdated implements UneeqMessage {
    readonly chatMetadata: ChatMetadata;
    uneeqMessageType: UneeqMessageType;
    constructor(chatMetadata: ChatMetadata);
}
